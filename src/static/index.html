<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>drcv upload (multi resumable)</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-200 font-mono min-h-screen flex flex-col items-center py-10">
  <h1 class="text-3xl font-bold text-green-400 mb-6">drcv uploader</h1>
  <p id="share-url" class="mb-4 text-sm text-gray-400"></p>
  
  <div class="w-full max-w-xl bg-gray-800 p-6 rounded-lg shadow-lg">
    <div id="connection-status" class="text-sm text-gray-400 mb-2"></div>
    
    <div id="dropzone" class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center mb-4 transition-all duration-200 hover:border-green-500 cursor-pointer">
      <div class="mb-4">
        <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
          <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
      </div>
      <div class="text-sm text-gray-300 mb-2">
        <span class="font-semibold text-green-400">Click to browse</span> or drag and drop files here
      </div>
      <div class="text-xs text-gray-500">
        Multiple files supported
      </div>
    </div>
    
    <input id="files" type="file" multiple class="hidden"/>
    
    <button id="uploadBtn" 
      class="w-full py-2 px-4 bg-green-600 hover:bg-green-500 rounded font-bold text-gray-900 mb-4">
      Upload
    </button>

    <h2 class="text-lg font-semibold mb-2">Current Uploads</h2>
    <div id="progress-container" class="space-y-4"></div>

    <h2 class="text-lg font-semibold mt-6 mb-2">Upload History</h2>
    <ul id="history" class="text-sm space-y-1"></ul>
  </div>

  <script>
    // Show the URL to share (useful when accessed via {hash}.drcv.app)
    (function(){
      const el = document.getElementById('share-url');
      const host = window.location.host;
      const proto = window.location.protocol;
      el.textContent = `Share this URL: ${proto}//${host}`;
    })();

    console.log('DRCV script starting...');
    const CHUNK_SIZE = (window.DRCV_CONFIG && window.DRCV_CONFIG.chunkSize) || (4 * 1024 * 1024); // default 4MB
    const fileInput = document.getElementById('files');
    const dropzone = document.getElementById('dropzone');
    const btn = document.getElementById('uploadBtn');
    const progressContainer = document.getElementById('progress-container');
    const historyList = document.getElementById('history');
    
    // 활성 업로드 ID들 관리
    const activeUploadIds = new Set();
    let heartbeatInterval = null;

    // --- Load history from localStorage ---
    function loadHistory() {
      const history = JSON.parse(localStorage.getItem("drcv-history") || "[]");
      historyList.innerHTML = "";
      history.forEach(item => {
        const li = document.createElement("li");
        const status = item.status || 'completed'; // 기존 데이터는 completed로 처리
        const statusIcon = status === 'completed' ? '✅' : status === 'canceled' ? '❌' : '⏸️';
        const statusText = status === 'completed' ? '' : ` (${status})`;
        li.textContent = `${statusIcon} ${item.filename}${statusText} (${new Date(item.date).toLocaleString()})`;
        historyList.appendChild(li);
      });
    }

    // --- Save history entry ---
    function saveHistory(filename, status = 'completed') {
      const history = JSON.parse(localStorage.getItem("drcv-history") || "[]");
      history.unshift({ filename, date: new Date().toISOString(), status }); // unshift로 맨 앞에 추가
      localStorage.setItem("drcv-history", JSON.stringify(history));
      loadHistory();
    }

    // 통합 heartbeat 함수
    function startHeartbeat() {
      if (heartbeatInterval) return; // 이미 실행 중
      
      const beat = async () => {
        if (activeUploadIds.size === 0) {
          // 활성 업로드가 없으면 heartbeat 중지
          clearInterval(heartbeatInterval);
          heartbeatInterval = null;
          return;
        }
        
        try {
          const response = await fetch('/heartbeat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ upload_ids: Array.from(activeUploadIds) })
          });
          const result = await response.text();
          console.log('Heartbeat result:', result);
        } catch (e) {
          console.log('Heartbeat failed:', e);
        }
      };

      // 즉시 한 번 보내고, 이후 주기적으로 보냄
      beat();
      heartbeatInterval = setInterval(beat, 10000); // 10초마다
    }

    loadHistory();

    // --- WebRTC P2P functionality ---
    let webrtcConnection = null;
    let webrtcDataChannel = null;
    let webrtcSessionId = null;
    let webrtcWebSocket = null;
    let connectionStatus = 'disconnected'; // 'connecting', 'p2p', 'http'

    async function initWebRTC() {
      try {
        connectionStatus = 'connecting';
        updateConnectionStatus();

        // Connect to signaling server
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/signaling`;
        webrtcWebSocket = new WebSocket(wsUrl);

        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('WebRTC connection timeout'));
          }, 10000); // 10 second timeout

          webrtcWebSocket.onopen = () => {
            console.log('Signaling WebSocket connected');
            // Request new session
            const message = { type: 'create_session' };
            console.log('Sending message:', message);
            webrtcWebSocket.send(JSON.stringify(message));
          };

          webrtcWebSocket.onmessage = async (event) => {
            try {
              const message = JSON.parse(event.data);
              console.log('Signaling message:', message);

              switch (message.type) {
                case 'session_created':
                  console.log('Session created:', message.session_id);
                  webrtcSessionId = message.session_id;
                  await setupPeerConnection();
                  clearTimeout(timeout);
                  resolve();
                  break;
                case 'offer':
                  console.log('Received offer for session:', message.offer.session_id);
                  webrtcSessionId = message.offer.session_id;
                  await setupPeerConnection();
                  await handleOffer(message.offer);
                  clearTimeout(timeout);
                  resolve();
                  break;
                case 'ice_candidate':
                  console.log('Received ICE candidate from server:', message.candidate.candidate);
                  if (webrtcConnection) {
                    try {
                      await webrtcConnection.addIceCandidate({
                        candidate: message.candidate.candidate,
                        sdpMid: message.candidate.sdp_mid,
                        sdpMLineIndex: message.candidate.sdp_mline_index
                      });
                      console.log('Added ICE candidate successfully');
                    } catch (error) {
                      console.error('Error adding ICE candidate:', error);
                    }
                  }
                  break;
                case 'error':
                  console.error('Signaling error:', message.message);
                  clearTimeout(timeout);
                  reject(new Error(message.message));
                  break;
                default:
                  console.warn('Unknown message type:', message.type);
              }
            } catch (error) {
              console.error('Error processing signaling message:', error);
              clearTimeout(timeout);
              reject(error);
            }
          };

          webrtcWebSocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            clearTimeout(timeout);
            reject(error);
          };

          webrtcWebSocket.onclose = () => {
            console.log('Signaling WebSocket closed');
            // If WebRTC connection is not established yet, fallback to HTTP
            setTimeout(() => {
              if (connectionStatus === 'connecting' && 
                  (!webrtcConnection || webrtcConnection.connectionState !== 'connected')) {
                console.log('📶 WebSocket closed, falling back to HTTP');
                connectionStatus = 'http';
                updateConnectionStatus();
                if (webrtcConnection) {
                  webrtcConnection.close();
                  webrtcConnection = null;
                }
              }
            }, 1000); // 1 second delay
          };
        });
      } catch (error) {
        console.error('WebRTC initialization failed:', error);
        throw error;
      }
    }

    async function setupPeerConnection() {
      webrtcConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun.cloudflare.com:3478' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      // Handle ICE candidates
      webrtcConnection.onicecandidate = (event) => {
        if (event.candidate && webrtcWebSocket?.readyState === WebSocket.OPEN) {
          console.log('Sending ICE candidate:', event.candidate.candidate);
          webrtcWebSocket.send(JSON.stringify({
            type: 'ice_candidate',
            candidate: {
              candidate: event.candidate.candidate,
              sdp_mid: event.candidate.sdpMid,
              sdp_mline_index: event.candidate.sdpMLineIndex,
              session_id: webrtcSessionId
            }
          }));
        } else if (!event.candidate) {
          console.log('ICE gathering completed');
        }
      };

      // Handle connection state changes
      webrtcConnection.onconnectionstatechange = () => {
        console.log('WebRTC connection state:', webrtcConnection.connectionState);
        if (webrtcConnection.connectionState === 'connected') {
          connectionStatus = 'p2p';
          updateConnectionStatus();
          console.log('🎉 WebRTC P2P connection established!');
        } else if (webrtcConnection.connectionState === 'failed' || 
                   webrtcConnection.connectionState === 'disconnected') {
          console.log('⚠️ WebRTC connection failed, falling back to HTTP');
          connectionStatus = 'http';
          updateConnectionStatus();
        }
      };
      
      // Set up connection timeout fallback
      setTimeout(() => {
        console.log('Timeout check - connection state:', webrtcConnection?.connectionState);
        if (webrtcConnection && 
            (webrtcConnection.connectionState === 'connecting' || 
             webrtcConnection.connectionState === 'new' ||
             webrtcConnection.iceConnectionState === 'checking' ||
             webrtcConnection.iceConnectionState === 'new')) {
          console.log('⏱️ WebRTC connection timeout, falling back to HTTP');
          connectionStatus = 'http';
          updateConnectionStatus();
          if (webrtcConnection) {
            webrtcConnection.close();
            webrtcConnection = null;
          }
        }
      }, 10000); // 10 second timeout
      
      // Handle ICE connection state changes
      webrtcConnection.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', webrtcConnection.iceConnectionState);
        if (webrtcConnection.iceConnectionState === 'failed' || 
            webrtcConnection.iceConnectionState === 'disconnected') {
          console.log('⚠️ ICE connection failed/disconnected, falling back to HTTP');
          connectionStatus = 'http';
          updateConnectionStatus();
          if (webrtcConnection) {
            webrtcConnection.close();
            webrtcConnection = null;
          }
        } else if (webrtcConnection.iceConnectionState === 'connected') {
          console.log('🎉 ICE connection established!');
          connectionStatus = 'p2p';
          updateConnectionStatus();
        }
      };

      // Handle incoming data channels
      webrtcConnection.ondatachannel = (event) => {
        webrtcDataChannel = event.channel;
        console.log('Received data channel:', webrtcDataChannel.label);
        
        webrtcDataChannel.onopen = () => {
          console.log('Data channel opened');
          connectionStatus = 'p2p';
          updateConnectionStatus();
        };

        webrtcDataChannel.onmessage = (event) => {
          console.log('Data channel message:', event.data);
        };
      };
    }

    async function handleOffer(offer) {
      try {
        console.log('Setting remote description with offer:', offer);
        await webrtcConnection.setRemoteDescription({
          type: 'offer',
          sdp: offer.sdp
        });
        console.log('Creating answer...');
        const answer = await webrtcConnection.createAnswer();
        console.log('Setting local description with answer...');
        await webrtcConnection.setLocalDescription(answer);

        console.log('Sending answer to server...');
        webrtcWebSocket.send(JSON.stringify({
          type: 'answer',
          answer: {
            sdp: answer.sdp,
            session_id: webrtcSessionId
          }
        }));
        console.log('Answer sent successfully');
      } catch (error) {
        console.error('Error in handleOffer:', error);
        throw error;
      }
    }

    function updateConnectionStatus() {
      const statusElement = document.getElementById('connection-status');
      if (!statusElement) return;

      switch (connectionStatus) {
        case 'connecting':
          statusElement.innerHTML = '🔄 Connecting via P2P...';
          statusElement.className = 'text-sm text-yellow-400 mb-2';
          break;
        case 'p2p':
          statusElement.innerHTML = '🚀 Connected via P2P • Direct transfer';
          statusElement.className = 'text-sm text-green-400 mb-2';
          break;
        case 'http':
          statusElement.innerHTML = '🌐 Using HTTP relay • Stable connection';
          statusElement.className = 'text-sm text-blue-400 mb-2';
          break;
        default:
          statusElement.innerHTML = '';
          break;
      }
    }

    // Try to initialize WebRTC on page load
    console.log('Page loaded, trying to initialize WebRTC...');
    initWebRTC().catch(error => {
      console.log('WebRTC initialization failed, will use HTTP fallback:', error);
      connectionStatus = 'http';
      updateConnectionStatus();
    });

    // --- Drag & Drop functionality ---
    // Click to browse
    dropzone.addEventListener('click', () => {
      fileInput.click();
    });

    // File input change handler
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        updateDropzoneState(e.target.files.length);
      }
    });

    // Drag & Drop event handlers
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      dropzone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, unhighlight, false);
    });

    dropzone.addEventListener('drop', handleDrop, false);

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    function highlight(e) {
      dropzone.classList.remove('border-gray-600', 'hover:border-green-500');
      dropzone.classList.add('border-green-500', 'bg-green-900', 'bg-opacity-20');
    }

    function unhighlight(e) {
      dropzone.classList.remove('border-green-500', 'bg-green-900', 'bg-opacity-20');
      dropzone.classList.add('border-gray-600', 'hover:border-green-500');
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      fileInput.files = files;
      updateDropzoneState(files.length);
    }

    function updateDropzoneState(fileCount) {
      const textDiv = dropzone.querySelector('.text-sm');
      const subtextDiv = dropzone.querySelector('.text-xs');
      
      if (fileCount > 0) {
        const files = Array.from(fileInput.files);
        const fileNames = files.map(f => f.name);
        
        textDiv.innerHTML = `<span class="font-semibold text-green-400">${fileCount} file${fileCount > 1 ? 's' : ''} selected</span> • Click to change`;
        
        if (fileNames.length <= 5) {
          subtextDiv.innerHTML = fileNames.map(name => `<div class="text-left">${name}</div>`).join('');
        } else {
          const firstFive = fileNames.slice(0, 5);
          subtextDiv.innerHTML = firstFive.map(name => `<div class="text-left">${name}</div>`).join('') + 
                                `<div class="text-left text-gray-400">... and ${fileNames.length - 5} more</div>`;
        }
        
        dropzone.classList.add('border-green-500');
        dropzone.classList.remove('border-gray-600');
      } else {
        textDiv.innerHTML = '<span class="font-semibold text-green-400">Click to browse</span> or drag and drop files here';
        subtextDiv.innerHTML = 'Multiple files supported';
        dropzone.classList.remove('border-green-500');
        dropzone.classList.add('border-gray-600');
      }
    }

    // Upload multiple files with limited concurrency
    btn.addEventListener('click', async () => {
      const files = Array.from(fileInput.files || []);
      if (!files.length) return alert("Select files first");
      progressContainer.innerHTML = "";

      // Reset dropzone after starting upload
      fileInput.value = '';
      updateDropzoneState(0);

      const limit = 3; // parallel uploads for multiple files
      let idx = 0;
      const workers = Array.from({ length: Math.min(limit, files.length) }, async () => {
        while (idx < files.length) {
          const myIndex = idx++;
          const f = files[myIndex];
          await uploadFile(f);
        }
      });
      await Promise.all(workers);
    });

    async function uploadFile(file) {
      // Create progress row
      const wrapper = document.createElement("div");
      wrapper.className = "bg-gray-700 p-3 rounded";

      const title = document.createElement("div");
      title.textContent = file.name;
      title.className = "mb-2 text-sm font-bold";
      
      let uploadId = null;

      const progressWrapper = document.createElement("div");
      progressWrapper.className = "mb-2";
      
      const progress = document.createElement("progress");
      progress.max = 100;
      progress.value = 0;
      progress.className = "w-full h-3";
      
      const progressText = document.createElement("div");
      progressText.textContent = "0% • 0 KB/s";
      progressText.className = "text-xs text-gray-400 mt-1";
      
      progressWrapper.appendChild(progress);
      progressWrapper.appendChild(progressText);

      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Cancel";
      cancelBtn.className = "px-3 py-1 bg-red-600 hover:bg-red-500 rounded text-xs font-bold text-white";
      
      let isCanceled = false;
      cancelBtn.addEventListener('click', () => {
        isCanceled = true;
        wrapper.style.opacity = "0.5";
        cancelBtn.disabled = true;
        cancelBtn.textContent = "Canceled";
        cancelBtn.className = "px-3 py-1 bg-gray-500 rounded text-xs font-bold text-white cursor-not-allowed";
        saveHistory(file.name, 'canceled');
        
        // 활성 업로드 목록에서 제거
        if (uploadId) {
          activeUploadIds.delete(parseInt(uploadId));
        }
      });

      wrapper.appendChild(title);
      wrapper.appendChild(progressWrapper);
      wrapper.appendChild(cancelBtn);
      progressContainer.appendChild(wrapper);

      // 1. Check resume status
      const headResp = await fetch(`/upload?filename=${encodeURIComponent(file.name)}`, { method: "HEAD" });
      let uploadedBytes = parseInt(headResp.headers.get("x-uploaded-bytes") || "0");
      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
      let startChunk = Math.floor(uploadedBytes / CHUNK_SIZE);
      let emaBps = null; // exponential moving average of bytes/sec

      // 2. Upload remaining chunks
      for (let i = startChunk; i < totalChunks; i++) {
        if (isCanceled) {
          console.log(`Upload canceled for ${file.name}`);
          return;
        }

        const start = i * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, file.size);
        const blob = file.slice(start, end);

        const formData = new FormData();
        formData.append("chunk", blob);
        formData.append("filename", file.name);
        formData.append("chunk_index", i);
        formData.append("total_chunks", totalChunks);

        const tStart = performance.now();
        const response = await fetch("/upload", { method: "POST", body: formData });
        const tEnd = performance.now();
        if (!response.ok) {
          const errorText = await response.text();
          alert(`❌ Upload failed: ${errorText}`);
          return;
        }
        
        // 첫 번째 chunk 업로드 후 uploadId 추출
        if (i === startChunk && !uploadId) {
          uploadId = await response.text();
          console.log("Upload ID:", uploadId);
          
          // 활성 업로드 목록에 추가 및 heartbeat 시작
          activeUploadIds.add(parseInt(uploadId));
          startHeartbeat();
        }

        // Update progress percent and speed
        const elapsedSec = Math.max((tEnd - tStart) / 1000, 0.001);
        const instBps = blob.size / elapsedSec;
        emaBps = emaBps == null ? instBps : (emaBps * 0.7 + instBps * 0.3);
        const progressPercent = (((i + 1) / totalChunks) * 100).toFixed(1);
        progress.value = parseFloat(progressPercent);
        progressText.textContent = `${progressPercent}% • ${formatSpeed(emaBps)}`;
      }

      // 활성 업로드 목록에서 제거
      if (uploadId) {
        activeUploadIds.delete(parseInt(uploadId));
      }
      
      if (!isCanceled) {
        saveHistory(file.name);
        // 완료된 업로드를 current uploads에서 제거
        wrapper.remove();
      }
    }

    function formatSpeed(bps) {
      if (!isFinite(bps) || bps <= 0) return '0 KB/s';
      const KB = 1024;
      const MB = KB * 1024;
      if (bps >= MB) return `${(bps / MB).toFixed(1)} MB/s`;
      if (bps >= KB) return `${(bps / KB).toFixed(1)} KB/s`;
      return `${Math.max(1, Math.round(bps))} B/s`;
    }
  </script>
</body>
</html>
